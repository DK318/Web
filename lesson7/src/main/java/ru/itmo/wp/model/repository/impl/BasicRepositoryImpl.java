package ru.itmo.wp.model.repository.impl;

import ru.itmo.wp.model.database.DatabaseUtils;
import ru.itmo.wp.model.exception.RepositoryException;

import javax.sql.DataSource;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;

public abstract class BasicRepositoryImpl<T> {
    private final DataSource DATA_SOURCE = DatabaseUtils.getDataSource();

    protected Object abstractSelectQuery(String query, List<Object> args,
                                         CheckedBiFunction<ResultSetMetaData, ResultSet, Object> function) {
        return abstractQuery(query, null, args, this::selectBody, function);
    }

    private Object selectBody(PreparedStatement statement, T obj, List<Object> args,
                              CheckedBiFunction<ResultSetMetaData, ResultSet, Object> function) throws SQLException {
        if (args != null) {
            for (int i = 0; i < args.size(); i++) {
                statement.setObject(i + 1, args.get(i));
            }
        }

        try (ResultSet resultSet = statement.executeQuery()) {
            return function.apply(statement.getMetaData(), resultSet);
        }
    }

    private Object insertBody(PreparedStatement statement, T obj, List<Object> args,
                              CheckedBiFunction<ResultSetMetaData, ResultSet, Object> function) throws SQLException {
        makeStatement(statement, obj, args);
        if (statement.executeUpdate() != 1) {
            throw new RepositoryException("Can't save object.");
        } else {
            ResultSet generatedKeys = statement.getGeneratedKeys();
            if (generatedKeys.next()) {
                setGeneratedFields(obj, generatedKeys);
            } else {
                throw new RepositoryException("Can't save object [no autogenerated fields].");
            }
        }
        return null;
    }

    private Object updateBody(PreparedStatement statement, T obj, List<Object> args,
                              CheckedBiFunction<ResultSetMetaData, ResultSet, Object> function) throws SQLException {
        if (args != null) {
            for (int i = 0; i < args.size(); i++) {
                statement.setObject(i + 1, args.get(i));
            }
        }
        if (statement.executeUpdate() != 1) {
            throw new RepositoryException("Can't update hidden of article.");
        }
        return null;
    }

    private Object abstractQuery(String query, T obj, List<Object> args,
                                 CheckedQuadFunction<PreparedStatement, T, List<Object>,
                                         CheckedBiFunction<ResultSetMetaData, ResultSet, Object>, Object> function, CheckedBiFunction<ResultSetMetaData, ResultSet, Object> evalFunction) {
        try (Connection connection = DATA_SOURCE.getConnection()) {
            try (PreparedStatement statement = connection.prepareStatement(query, Statement.RETURN_GENERATED_KEYS)) {
                return function.apply(statement, obj, args, evalFunction);
            }
        } catch (SQLException e) {
            throw new RepositoryException("Can't find object", e);
        }
    }

    protected void abstractInsertQuery(String query, T obj, List<Object> args) {
        abstractQuery(query, obj, args, this::insertBody, null);
    }

    protected void abstractUpdateQuery(String query, List<Object> args) {
        abstractQuery(query, null, args, this::updateBody, null);
    }

    private Method getClassMethod(Class<?> clazz, String methodName, Class<?>... parameterTypes) throws NoSuchMethodException {
        try {
            return clazz.getDeclaredMethod(methodName, parameterTypes);
        } catch (NoSuchMethodException e) {
            // No operations.
        }

        for (Method method : clazz.getMethods()) {
            String name = method.getName();

            if (methodName.equals(name)) {
                if (parameterTypes.length == 0) {
                    return method;
                }

                Class<?>[] acceptedParameterTypes = method.getParameterTypes();

                if (acceptedParameterTypes.length == parameterTypes.length) {
                    boolean f = true;

                    for (int i = 0; i < acceptedParameterTypes.length; i++) {
                        if (parameterTypes[i] != null && !acceptedParameterTypes[i].isAssignableFrom(parameterTypes[i])) {
                            f = false;
                            break;
                        }
                        if (parameterTypes[i] != null && acceptedParameterTypes[i].isPrimitive()) {
                            f = false;
                            break;
                        }
                    }

                    if (f) {
                        return method;
                    }
                }
            }
        }
        throw new NoSuchMethodException("There is no method" + methodName);
    }

    protected T toObject(ResultSetMetaData metaData, ResultSet resultSet) throws SQLException {
        if (!resultSet.next()) {
            return null;
        }

        @SuppressWarnings("unchecked")
        Class<T> parameterClass = (Class<T>) ((ParameterizedType)getClass().getGenericSuperclass())
                .getActualTypeArguments()[0];

        T obj;
        try {
            //noinspection deprecation
            obj = parameterClass.newInstance();
        } catch (InstantiationException | IllegalAccessException e) {
            throw new RepositoryException("Can't create generic object");
        }

        for (int i = 1; i <= metaData.getColumnCount(); i++) {
            String columnName = metaData.getColumnName(i);

            StringBuilder builder = new StringBuilder(columnName);
            builder.setCharAt(0, Character.toUpperCase(builder.charAt(0)));
            columnName = builder.toString();

            String setterName = "set" + columnName;
            Method setterMethod;
            try {
                setterMethod = getClassMethod(parameterClass, setterName);
            } catch (NoSuchMethodException e) {
                continue;
            }

            Class<?> setterArg = setterMethod.getParameterTypes()[0];

            String valueName = setterArg.getSimpleName();
            builder = new StringBuilder(valueName);
            builder.setCharAt(0, Character.toUpperCase(builder.charAt(0)));
            valueName = builder.toString();

            Method resultSetGetter;

            try {
                resultSetGetter = getClassMethod(resultSet.getClass(), "get" + valueName, int.class);
            } catch (NoSuchMethodException e) {
                throw new RepositoryException("Something went wrong");
            }

            Object val;
            try {
                val = resultSetGetter.invoke(resultSet, i);
            } catch (IllegalAccessException | InvocationTargetException e) {
                throw new RepositoryException("Something went wrong");
            }

            try {
                setterMethod.invoke(obj, val);
            } catch (IllegalAccessException e) {
                throw new RepositoryException("Domain setter method " + setterName + " should be public");
            } catch (InvocationTargetException e) {
                throw new RepositoryException("Domain should contain setter " + setterName);
            }
        }

        return obj;
    }

    protected abstract void makeStatement(PreparedStatement statement, T obj, List<Object> args) throws SQLException;

    protected abstract void setGeneratedFields(T obj, ResultSet generatedKeys) throws SQLException;

    protected List<T> addAll(ResultSetMetaData metaData, ResultSet resultSet) throws SQLException {
        List<T> objs = new ArrayList<>();
        T obj;
        while ((obj = toObject(metaData, resultSet)) != null) {
            objs.add(obj);
        }
        return objs;
    }

    @FunctionalInterface
    protected interface CheckedBiFunction<T, U, R> {
        R apply(T x, U y) throws SQLException;
    }

    @FunctionalInterface
    protected interface CheckedQuadFunction<T, U, P, S, R> {
        R apply(T x, U y, P z, S a) throws SQLException;
    }
}
